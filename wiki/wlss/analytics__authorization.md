[wiki](../../README.md) / [wlss](./index.md) /


# Аналитика. Авторизация

Эта статья содержит описание основных концепций, применяемых для авторизации в современном программировании. Многие технические детали специально пропущены, т.к. цель этого описания в том, чтобы дать понимание самой идеи, для чего используются те или иные подходы и какие проблемы они решают. Если будет необходимость в более подробном описании деталей технической реализации, то для этого можно будет завести отдельную статью.

Описание начинается от самых простых проблем, которые даже могут показаться странными, т.к. эти проблемы обычно сразу решены по умолчанию, поэтому у разработчиков подобные вопросы могут даже не возникать. Но с каждой новой проблемой, совокупность всех используемых решений будет приближаться к современной реализации авторизации используемой в современных системах.

***

**Проблема**

Пользователь хочет выполнять различные действия в системе от своего имени. А также система хочет знать, кем был сделан запрос на выполнение того или иного действия, чтобы ограничить доступ к определённым дейстиям для определённых пользователей.

**Решение**

Перед совершением каого-либо действия пользователь предоставляет системе свой логин и пароль, клиентское приложение отправляет их на сервер, где сервер проверяет существует ли такой пользователь в базе данных и есть ли у него право на выполнение запрашиваемого действия.

**Результат**

Система сможет идентифицировать пользователя и проверять его права, а пользователь сможет совершать действия в системе от своего имени.

***

**Проблема**

Пользователь не хочет вводить логин и пароль перед каждым действием, которое он совершает в системе.

**Решение**

Пользователь вводит логин и пароль один раз, клиентское приложение передаёт их на сервер, где проверяется их валидность. И если они валидны, то сервер возвращает клиентскому приложению какой-нибудь уникальный идентификатор, который связан с этим пользователем и хранится в базе данных. После этого при выполнении какого-либо действия пользователем в системе, клиентское приложение будет передавать этот идентификатор в каждом запросе к серверу, чтобы сервер мог найти этот идентификатор в базе данных и понять от какого пользователя пришёл запрос.

**Результат**

Пользователю нужно ввести логин и пароль только один раз, после этого все запросы от клиентского приложения будут использовать уникальный идентификатор, выданный сервером.

***

**Проблема**

Уникальный идентификатор может быть скомпрометирован (украден) и использоваться злоумышленниками, которые будут выполнять действия в системе от имени пользователя.

**Решение**

Ограничить срок жизни этого уникального идентификатора, например до 1 дня. При создании этого короткоживущего идентификатора, сервер будет сохранять в базе данных дату, до которой этот идентификатор будет считаться валидным. Таким образом каждый раз когда пользователь выполняет какое-либо действие в системе, клиентское приложение передаёт запрос на сервер с использованием короткоживущиего идентификатора, сервер будет проверять его срок, и если срок истёк, то идентификатор стирается из базы, и пользователю нужно снова вводить логин и пароль для получения нового идентификатора.

**Результат**

Если идентификатор будет украден, то злоумышленники смогут работать от имени пользователя не дольше одного дня (время жизни идентификатора), после этого они попадут на форму логина, и поскольку логин и пароль пользователя они не знают, то дальше работать не смогут.

***

**Проблема**

Пользователь не хочет вводить логин и пароль каждый раз, когда истекает его короткоживущий идентификатор.

**Решение**

Вместе с этим идентификатором также отправлять второй уникальный идентификатор, который будет иметь более долгий срок жизни, например 1 месяц. Долгоживущий идентификатор будет использоваться для обновления короткоживущего идентификатора. Т.е. после того как пользователь входит в систему с помощью логина и пароля, клиентское приложения получает от сервера два идентификатора - короткоживущий и долгоживущий. Клиентское приложение будет отправлять короткоживущий идентификатор во всех запросах к серверу, для проверки прав пользователя на совершение какого-либо действия. Если его срок жизни истекает (он становится невалидным), то клиентское приложение отправялет особый запрос в котором передаёт долгоживущий идентификатор, и если он валидный, то сервер выдаёт в ответ новый короткоживущий идентификатор, который будет действовать ещё один день.

**Результат**

Пользователю не придётся вводить логин и пароль каждый раз когда истекает срок короткоживущего идентификатора - обновлением короткоживущего токена заниматься клиентское приложение.

***

**Проблема**


1. Пользователю нужно вводить логин и пароль каждый месяц (срок долгоживущего идентификатора).

2. Долгоживущий идентификатор может быть скомпрометирован и использоваться злоумышлениками, чтобы обновлять короткоживущие идентификаторы в течение месяца и всё это время выполнять действия в системе от имени пользователя.

**Решение**

При обновлении короткоживущего идентификатора обновлять также и долгоживущий. Т.е. при истечении срока короткоживущего идентификатора, клиентское приложение передаёт серверу валидный долгоживущий идентификатор и получает от него два новых - свежий короткоживущий, и свежий долгоживущий.

**Результат**

1. Пользователю не придётся вводить логин и пароль каждый месяц до тех пор пока он регулярно работает в системе. Т.к. при выполнении пользователем любого действия в системе оба его идентификатора будут обновляться. Если же он за месяц не совершил никаких действий в системе, то его долгоживущий идентификатор оказывается истекшим, и пользователю придётся ввести логин и пароль.

2. Даже если долгоживущий идентификатор будет скомпрометирован, то после того как приложение настоящего пользователя обновит идентификаторы, то скомпрометированный долгоживущий идентификатор станет невалидным, т.к. система выдала пользователю другой долгоживущий и удалила старый из базы данных. И поскольку долгоживущий идентификатор злоумышленника стал невалидным, злоумышленнику придётся вводить логин и пароль, чтобы получить новые идентификаторы.

   Если же например злоумышленник успел обновить идентификаторы, по украденному долгоживущему идентификатору до того как это сделал настоящий пользователь, то долгоживущий идентификатор настоящего пользователя станет невалидным для системы, и она попросить его ввести логин и пароль. А так как пользователь знает свой логин и пароль, то он получит свежие идентификаторы, а украденный идентификатор злоумышленника станет невалидным и злоумышленнику также придётся вводить логин и пароль, а он их не знает. Таким образом злоумышленник сможет работать с системой по скомпрометированному идентификатору только до тех пор, пока реальный пользователь не попробует выполнить какое-либо действие в системе и не введёт логин и пароль заново, после этого идентификаторы злоумышленника станут невалидными.

***

**Проблема**

Пользователь работает с нашей системой с двух разных устройств (например с двух разных компьютеров - "A" и "B"). Пользователь работает за компьютером "A". Клиентское приложения компьютера "A" получает от сервера два идентификатора short_A и long_A. Пользователь переходит за компьютер "B". Клиентское приложение компьютера "B" получает от сервера два других идентификатора - short_B и long_B. Как только сервер выдал компьютеру "B" долгоживущий идентификатор long_B, то долгоживущий идентификатор компьютера "A" (long_A) стал невалидным, и пользователю придётся заново вводить свой логин и пароль на компьютере "A".

**Решение**

Сервер может хранить в базе данных запись о том, к какому устройству принадлежит тот или иной долгоживущий идентификатор. Т.е. когда пользователь вводит свой логин и пароль на новом устройстве, клиентское приложение отправляет их на сервер, сервер проверяет их валидность, генерирует короткоживущий и долгоживущий идентификаторы, а также идентификатор устройства (может быть просто числом уникальным в рамках всех устройств одного пользователя). Сохраняет эти идентификаторы в базе данных для этого пользователя и отдаёт клиентскому приложению. После этого все запросы клиентского приложения на обновление идентификаторов должны содержать также и выданный ему идентификатор устройства, таким образом сервер сможет отличать разные устройства пользователя и обновлять короткоживущие и долгоживущие идентификаторы для каждого устройства независимо.

**Результат**

Поскольку каждому устройству будет выдаваться свой отдельный долгоживущий идентификатор, то они станут независимыми друг от друга и тот факт, что пользователь залогинился или разлогинился на одном устройстве не будет влиять на все остальные устройства. Если же пользователь захочет разлогиниться на всех устройствах, то клиентское приложение может отправить отдельный запрос на сервер, по которому сервер удалит все идентификаторы и всю информацию о привязке этих идентификаторов к девайсам пользователя.

***

<details>
<summary>Авторизация с использованием стороннего сервиса</summary>
<p>

**Ниже идёт отдельный раздел отвечающий за регистрацию/логин на стороннем сервисе. Проблемы описанные в них могут быть пропущены, и тогда мы получим реализацию OAuth в рамках одного (нашего) сервиса, без помощи сторонних авторизующих ресурсов.**

_Этот раздел незавершен, т.е. он может не содержать каких-то подробностей, но т.к. для реализации вишера нам пока что не нужна авторизация через сторонний авторизующий ресурс, то пока что оставим его как есть. В будущем скорее всего этот раздел будет дополняться по мере необходимости._

***

**Проблема**

Пользователь не хочет запоминать много пар логин/пароль от всех сервисов в которых он зарегистрирован.

**Решение**

Вместо заполнения формы логина в нашей системе, мы можем редиректить пользователя в сервис, в котором он уже зарегистрирован, где он пройдёт процедуру логина и получит оттуда короткоживущий и долгоживущий идентификаторы, которые используются в том сервисе. В нашей системе мы свяжем эти идентификаторы с пользователем и будем знать, что каждый запрос содержащий этот идентификатор был отправлен именно этим пользователем. В случае если срок идентификатора истекает, то для его обновления мы обращаемся к тому сервису, от которого он был получен.

**Результат**

Пользователь может помнить только логин и пароль от авторизующего сервиса и через него попадать в нашу систему (и в другие системы, которые прошли интеграцию с этим авторизующим сервисом).

***

**Проблема**

Наш сервис должен быть уверен в том, что идентификаторы были получены именно из того сервиса, на который мы редиректили пользователя.

**Решение**

На этапе интеграции нашей системы с таким сторонним сервисом, этот сервис должен передать нам секретный ключ, который будет использоваться для подписания идентификатора на их стороне, а мы в свою очередь с помощью этого ключа на своей стороне сможем проверить эту подпись. Т.к. этот ключ известен только нам и тому сервису, с которым  мы интегрируемся, то злоумышленники не смогут подделать подпись этого идентификатора, а значит, проверив подпись, мы можем быть уверены, что идентификатор пришёл из правильного источника и не был подделан по пути.

**Результат**

Мы всегда будем понимать, что идентификатор получен от конкретного стороннего сервиса после того как пользователь прошёл в нём процедуру логина.

</p>
</details>

***

> Ссылка на [обсуждение](https://github.com/week-password/wisher/discussions/22).
