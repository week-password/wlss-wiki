[wiki](../../README.md) / [backend](index.md) /


# Разработка. Общий план MVP

Это общий план по разработке бэкенда для MVP. Это не список задач, хотя некоторые пункты возможно и могут выглядеть как уже декомпозированные задачи, но это не так. Задачи требуют более точных формулировок и требований, а тут всё описано в произвольном неформализованном виде. Этот текст составлен для того чтобы обсудить/уточнить те или иные решения и общий план разработки, а также чтобы было на что ориентироваться и понимать куда мы вообще движемся в процессе.

### Предварительная настройка окружения

1. **Добавление и настройка линтеров**.

    Хотелось бы, чтобы линтеры работали в проекте с первого коммита (баш скрипт не в счёт), и любой написанный код проверялся сразу. Предлагаю использовать следующие линтеры:

    - `mypy` - кажется, это must-have, и особо не имеет смысла расписывать, почему мы хотим его добавить :) Должен запускаться первым, т.к. проверяет код на наличие потенциальных багов. Т.е. нет смысла запускать линтеры, которые проверяют форматирование кода, до тех пор пока код сам по себе не работает или содержит баги. Хоть майпай работает относительно долго, но кажется его система кэширования, позволяет ускорить этот процесс. Также при разрастании кодовой базы можно настроить mypy-демон, который, по идее, должен еще больше ускорить работу.

    - `ruff` - новый инструмент, о котором очень много говорят. Хотелось бы попробовать и посмотреть на что он способен. Основная фича раффа это его скорость линтинга, поэтому кажется будет удобно им пользоваться во время разработки, чтобы получать моментальный фидбек. С моментом роста кодовой базы, выполнение линтеров будет занимать всё больше времени, но кажется что рафф имеет очень большой потенциал и будет справляться даже с большой кодовой базой.

    - `flake8` - старый добрый флейк, довольно быстрый (относительно майпая и пайлинта), а также неплохо зарекомендовал себя на практике. Работает медленнее раффа, поэтому во время разработки имеет смысл запускать его после того как рафф отработал без ошибок. В основном использование флейка имеет смысл только из-за его плагинов, т.к. есть плагины, которые проверяют штуки, которые не проверяет ни один другой линтер. Если какие-то проверки/плагины флейка дублируют функционал раффа, то их можно отключить, чтобы ускорить работу флейка.

    - `pylint` - работает долго, зато проверяет некоторые сложные вещи, которые недоступны другим инструментам. Предлагаю запускать его в самый последний момент, после того как все линтеры отработали без ошибок. Или воощбе перед финальным пушем ветки. В принципе на 12к кодовой базе работает около 30сек - что вроде как еще не сильно критично, а до 12к кодовой базы вишеру пока что еще далеко, так что жить будет можно. Если потом его скорость станет слишком критичной, можно вообще не запускать его локально, а только на CI, т.к. другие линтеры, которые будут запускаться локально, уже смогут найти нам большинство ошибок. А ошибки пайлинта можно будет посмотреть на CI. Но такой размер кодовой базы в любом случае будет еще очень нескоро.

    Возможно имеет смысл добавить автоформаттер, чтобы не спорить в мр-ах из-за форматирования кода. Но я пока не уверен в этом, т.к. боюсь, что использование автоформаттера расслабляет разработчиков, и со временем мы разучимся форматировать код без него.

    При добавлении первой либы в проект, нам уже нужно будет знать какую систему работы с пакетами мы будем использовать. Поэтому кажется с этим вопросом так же стоит определиться на этом этапе. Т.к. мы пробовали и pip и Pipenv, можно поэкспериментировать с Poetry. Хоть мне и не очень нравиться идея конфигурации через pyproject.toml, но возможно если этот файл будет содержать конфигурацию **только** для Poetry, а конфиги остальных тулов будут в своих соответствующих .rc/.ini файлах, то это будет не так уж и плохо. К тому же у poetry есть прекрассная фича групп зависимостей - очень хочется поработать с ней.

2. **CI для линтеров.**

    Как только мы добавим линтеры, хотелось бы сразу же включить их в CI пайплайн, чтобы все последующие мр-ы проверялись через CI и реджектились, если какой-то из линтеров даёт ошибку. На данный момент автоматизация CI через GitHub Actions это супер удобно и бесплатно, поэтому других вариантов не вижу. Возможно и хотелось бы попробовать что-нибудь новенькое типа TravisCI, но там как бы денюжку надо платить, да и время на знакомство с новым инструментом тоже где-то нужно взять. К тому же GitHub Actions уже стал серьезным конкурентом на рынке CI систем, несмотря на его малый возраст. Он развивается семимильными шагами, и кажется, и нельзя обходить такие штуки стороной. Этот тул определенно стоит того, чтобы его использовать.

3. **Тестирование.**

    Хотелось бы, чтобы с первого коммита, код сразу же проверялся тестами. На этом этапе надо будет настроить окружение для тестирования локально. Предлагаю для тестирования использовать следующие штуки:

    - `pytest` - ну тут, думаю, выбор очевиден, хороших альтернатив, кажется, пока что нет :)

    - `factory-boy` - так, как лучший подход по работе с фикстурами до сих пор не найден, можно поэкспериментировать с фэктори боем и посмотреть какие возможности он предоставляет. Может быть это решит наши проблемы с фикстурами, может быть нет. Будем смотреть по ходу. Хотя хорошо бы конечно предварительно провести ресёрч его возможностей, с примерами проблем, которые у нас возникали ранее, и как они могли бы быть решены через фэктори бой.

    - `pydantic-factories` -  позволяет создавать фабрики для factory-boy на основе pydantic-схем

    - `pytest-mock` - кажется, неплохая замена для `unittest.mock`. Позволяет избавиться от некоторого бойлерплейт-кода - например, от вложенных with при патчинге внутри теста.

4. **CI для тестирования.**

    Тестирование тоже нужно встроить в CI до начала непосредственной разработки функционала, чтобы случайно не влить что-то со сломанными тестами или с неполным покрытием.

5. **Добавление FastAPI.**

    Ну тут всё и так понятно - раз уж мы решили разрабатывать на фастапи, необходимо добавить его в проект, и написать простенький эндпойнт, чтобы проверить, что фастапи работает.

6. **Создание микросервиса PG.**

    Так как мы планируем хранить наши данные в постгресе, необходимо добавить базовую конфигурацию постгреса для разработки, тестов и CI. Настроить алембик и миграции. Создать моковую таблицу в бд и написать простенький эндпойнт, который будет добавлять записи в эту таблицу. Написать тест и проверить что он работает локально и на CI.

    На этом же шаге будет и подключение алхимии в проект. Предалагаю использовать вторую версию алхимии, т.к. в ней есть нативная поддержка типов и единый синтаксис запросов.

7. **Создание микросервиса MinIO.**

    Так как мы планируем работать с изображениями, например, с Аватарами Пользователя и Желания, необходимо настроить minio для разработки, тестов и CI. Добавить простенький эндпойнт, который будет создавать какой-нибудь документ в minio. Написать тест для этого эндпойнта и проверить, что это работает локально и на CI.

    Возможно, существуют какие-либо альтернативы для minio. Ресёрч не проводил. Мне в minio не хватает обработки файлов группами (папками). Но с другой стороны, кажется, что minio это наиболее популярная технология в индустрии по работе с файлами, и если мы будем его использовать то будем идти в ногу с текущими практиками принятыми во многих компаниях, что может помочь при трудоустройстве.

8. **Настройка стенда и CD.**

    Как только у нас появилось минимально рабочее "приложение" пусть даже с одним пинг-роутом и бд - надо как можно скорее настроить CD, т.к. чем проще приложение, тем проще настраивать CD для него.

    В рамках этого пункта так же надо будет настроить CD и для фронта, так что тут необходимо будет синхронизироваться с фронтом.

### Разработка функционала MVP

1. **Архитектура API - контракты для Пользователя.**

    Скорее всего разработка будет идти в том же порядке, который описан в [общем плане MVP по аналитике](https://github.com/week-password/wisher/wiki/%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D1%82%D0%B8%D0%BA%D0%B0.-%D0%9E%D0%B1%D1%89%D0%B8%D0%B9-%D0%BF%D0%BB%D0%B0%D0%BD-MVP). Начать необходимо с контрактов для работы с сущностью Пользователь - а именно - регистрация, логин, просмотр и редактирование профиля. Контракты нужно будет утверждать вместе с фронтом.

2. **Реализация контрактов для Пользователя.**

    После того как контракты для Пользователя зафиксированы, можно приступать к реализации. Теоретически, возможно стоило бы сначала разработать все контракты для MVP, и только потом приступать к реализации, но у такого подхода есть несколько минусов. Во-первых, при написании реализации, мы можем в какой-то момент понять, что наши контракты не идеальны и захотим их поменять. В таком случае чем больше контрактов у нас будет к тому моменту, тем больше нам придётся менять. Во-вторых, разработка и согласование всех контрактов для MVP надолго отложит фактическую реализацию, и скорее всего было бы лучше выкатывать функционал по чуть-чуть, но сразу. Хотя возмозжно, что фронту нужны будут **все** контракты как можно раньше, так что скорее всего этот пункт нужно будет обсудить, и возможно это повлияет на этот план разработки.

    Скорее всего где-то здесь у нас появятся реальные эндпойнты, которые работают с бд и minio, а также тесты к ним. Поэтому на этом этапе можно удалить моковые эндпойнты, бакеты и таблицы, которые мы насоздавали ранее, при настройке бд и minio.

3. **Архитектура API - контракты для Желания.**

    После реализации контрактов для Пользователя нужно будет разработать и согласовать контракты по работе с Желанием. А именно - создание, редактирование, удаление и бронирование Желания.

4. **Реализация контрактов для Желания.**

    Тут всё по той же схеме: разработали контракты - делаем реализацию.

5. **Архитектура API - контракты для Друзей.**

    После того как Желания добавлены в систему, необходимо скрыть Желания Пользователя от других Пользователей, которые не являются его Друзьями. Соответственно необходимо будет разработать контракты по поиску, добавлению и удалению Друзей.

6. **Реализация контрактов для Друзей.**

    Есть контракты - нужна реализация.

7. **Сокрытие желаний.**

    После того как мы реализовали работу с Друзьями, нужно будет добавить функциональность по ограничению простмотра желаний для Пользователей, которые не являются Друзьями текущего Пользователя.

### Всякое остальное, пока не знаю что.

Кажется после реализации контрактов для Друзей, основной функционал MVP будет готов, но скорее всего ещё останутся какие-то штуки, про которые я либо забыл написать здесь, либо которые можно отложить на конец. Например, эндпойнты для всяких юридических вещей, типа баннеров и страниц с пользовательскими соглашениями. Так же здесь могут быть выполнены какие-то задачи по рефакторингу или устранению какого-либо техдолга по MVP (если такой конечно появится).

***

> Ссылка на [обсуждение](https://github.com/week-password/wisher-backend/discussions/4).
